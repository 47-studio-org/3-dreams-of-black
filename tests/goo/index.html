<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js webgl - city</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				color: #808080;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				display:none;
			}

			a { color:red }

			.bar { width:100%; position:absolute; z-index:200; display:none }

			#oldie { z-index:500!important; margin-top:15em!important }

		</style>
	</head>

	<body>
		<div id="info">
			<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> - OBJ converter example
		</div>

		<div id="hud">
		</div>

		<div class="bar" id="topbar1"></div>
		<div class="bar" id="topbar2"></div>
		<div class="bar" id="bottombar1"></div>
		<div class="bar" id="bottombar2"></div>

		<script type="text/javascript" src="js/Three.js"></script>

		<script type="text/javascript" src="js/Detector.js"></script>
		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="js/Stats.js"></script>

		<script type="text/javascript">

			var Shaders = {

				'soup' : {

					uniforms: {

						"grassImage": { type: "t", value: 0, texture: null },
						"surfaceImage": { type: "t", value: 1, texture: null },
						"map": { type: "t", value:2, texture:null },

						"targetStart": { type: "v3", value: new THREE.Vector3() },
						"targetEnd": { type: "v3", value: new THREE.Vector3() }

					},

					vertexShader: [

						"varying vec3 vWorldPosition;",
						"varying vec3 vNormal;",
						"varying vec2 vUv;",

						"void main() {",

							"vNormal = normalize( normalMatrix * normal );",
							"vNormal *= vNormal;",
							
							"vUv = uv;",

							"vWorldPosition = vec3( objectMatrix * vec4( position, 1.0 )).xyz;",
							"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

						"}"

					].join("\n"),

					fragmentShader: [

						"uniform sampler2D grassImage;",
						"uniform sampler2D surfaceImage;",
						"uniform sampler2D map;",
						"uniform vec3 targetStart;",
						"uniform vec3 targetEnd;",

						"varying vec3 vWorldPosition;",
						"varying vec3 vNormal;",
						"varying vec2 vUv;",
						"varying float vPointOnLine;",

						"void main() {",

							"float distance;",
							"vec3 normal;",
							"vec4 surface;",
							"vec4 grass;",

							"vec3 worldPosition = vWorldPosition * 0.005;",

							"vec3 pointStart = vWorldPosition - targetStart;",
							"vec3 endStart = targetEnd - targetStart;",
							"float endStartLength2 = pow( length( endStart ), 2.0 );",
							"float pointOnLine = clamp( dot( endStart, pointStart ) / endStartLength2, 0.0, 1.0 );",

							"distance  = 1.0 - length( vWorldPosition - ( targetStart + pointOnLine * ( targetEnd - targetStart ))) * 0.01;",
							"distance += texture2D( grassImage, worldPosition.xz ).g - 0.5;",
							
							"surface = texture2D( surfaceImage, worldPosition.yz ) * vNormal.x + ",
							          "texture2D( surfaceImage, worldPosition.xz ) * vNormal.y + ",
							          "texture2D( surfaceImage, worldPosition.xy ) * vNormal.z;",

							"if( distance >= 0.0 ) {",

								"grass = texture2D( grassImage, worldPosition.yz ) * vNormal.x + ",
								        "texture2D( grassImage, worldPosition.xz ) * vNormal.y + ",
								        "texture2D( grassImage, worldPosition.xy ) * vNormal.z;",
	
								"surface = mix( surface, grass, smoothstep( 0.0, 0.1, distance ));",
	
							"}",
	
							"gl_FragColor = surface * texture2D( map, vUv );",
						"}"

					].join("\n")

				},
				

				//////////////// POST SHADER //////////////////////

				'post' : {

					uniforms: {

						"map": { type: "t", value:0, texture:null },

					},

					vertexShader: [

						"varying vec2 vUv;",

						"void main() {",

							"vUv = uv;",
							"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

						"}"

					].join("\n"),

					fragmentShader: [

						"uniform sampler2D map;",
						"varying vec2 vUv;",

						"void main() {",

							"vec4 color, tmp, add;",
							
							"vec2 uv = vUv + vec2( sin( vUv.y * 100.0 ), sin( vUv.x * 100.0 )) * 0.0005;",
							
							"color = texture2D( map, uv );",

							"add = tmp = texture2D( map, uv + vec2( 0.0008, 0.0008 ));", 
							"if( tmp.r < color.r ) color = tmp;",

							"add += tmp = texture2D( map, uv + vec2( -0.0008, 0.0008 ));",
							"if( tmp.r < color.r ) color = tmp;",

							"add += tmp = texture2D( map, uv + vec2( -0.0008, -0.0008 ));",
							"if( tmp.r < color.r ) color = tmp;",

							"add += tmp = texture2D( map, uv + vec2( 0.0008, -0.0008 ));",
							"if( tmp.r < color.r ) color = tmp;",

							"add += tmp = texture2D( map, uv + vec2( 0.001, 0.0 ));",
							"if( tmp.r < color.r ) color = tmp;",

							"add += tmp = texture2D( map, uv + vec2( -0.001, 0.0 ));",
							"if( tmp.r < color.r ) color = tmp;",

							"add += tmp = texture2D( map, uv + vec2( 0, 0.001 ));",
							"if( tmp.r < color.r ) color = tmp;",

							"add += tmp = texture2D( map, uv + vec2( 0, -0.001 ));",
							"if( tmp.r < color.r ) color = tmp;",


							"gl_FragColor = color * color + add * 0.5 / 8.0;",
//							"gl_FragColor = texture2D( map, uv );",
						"}"

					].join("\n")

				}

				

			};

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var height = window.innerHeight;

			var container,stats;

			var camera, cameraOrtho, scene, sceneScreen, quadScreen, renderer, materialShader, renderTarget;

			var targetStart, targetEnd;

			var mesh, zmesh, geometry, materials, timer = new THREE.Vector2();

			var mouseX = 0, mouseY = 0, r = 0;
			var renderPost = true;
			
			function bind( scope, fn ) {
		
				return function () {
		
					fn.apply( scope, arguments );
		
				};
		
			};
			

			init();
			animate();


			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);
				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'keydown', bind( this, this.onKeyDown ), false );

				scene = new THREE.Scene();
				camera = new THREE.QuakeCamera( { fov: 50, aspect: window.innerWidth / window.innerHeight, near: 1, far: 10000, movementSpeed: 5 } );
				camera.position.set( 0, 200, 0 );


				cameraOrtho = new THREE.Camera();
				cameraOrtho.projectionMatrix = THREE.Matrix4.makeOrtho( window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -10000, 10000 );
				cameraOrtho.position.z = 100;

				renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { depthBuffer: true, stencilBuffer: true } );
				renderTarget.minFilter = THREE.LinearFilter;
				renderTarget.magFilter = THREE.LinearFilter;
				
				sceneScreen = new THREE.Scene();
				
				
				Shaders[ 'post' ].uniforms.map.texture = renderTarget;
				
				var postMaterial = new THREE.MeshShaderMaterial( {
					
					uniforms: Shaders[ 'post' ].uniforms,
					vertexShader: Shaders[ 'post' ].vertexShader,
					fragmentShader: Shaders[ 'post' ].fragmentShader
					
				} );
				
				quadScreen = new THREE.Mesh( new Plane( window.innerWidth, window.innerHeight ), postMaterial );
				quadScreen.position.z = -100;
				quadScreen.rotation.z = Math.PI;
				quadScreen.scale.x = -1;
				quadScreen.doubleSided = true;
				sceneScreen.addObject( quadScreen );





				var geom = new Sphere( 5, 5, 5 );

				targetStart = new THREE.Mesh( geom, new THREE.MeshBasicMaterial( { color: 0xff0000 } ) );
				targetEnd   = new THREE.Mesh( geom, new THREE.MeshBasicMaterial( { color: 0x00ff00 } ) );
				
				scene.addChild( targetStart );
				scene.addChild( targetEnd );

	
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.addChild( light ); 



				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				container.appendChild( renderer.domElement );
				renderer.setClearColor( 0xffffff );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );


				var loader = new THREE.JSONLoader(), callbackScene = function( geometry ) {

					// setup base material
 
					var shader = Shaders[ 'soup' ];
					var uniforms = shader.uniforms;

					uniforms[ 'grassImage' ].texture = ImageUtils.loadTexture( 'opengl/Texture_Grass.jpg' );
					uniforms[ 'grassImage' ].texture.wrapS = THREE.RepeatWrapping;
					uniforms[ 'grassImage' ].texture.wrapT = THREE.RepeatWrapping;

					uniforms[ 'surfaceImage' ].texture = ImageUtils.loadTexture( 'opengl/Texture_Pavement.jpg' );
					uniforms[ 'surfaceImage' ].texture.wrapS = THREE.RepeatWrapping;
					uniforms[ 'surfaceImage' ].texture.wrapT = THREE.RepeatWrapping;

					var baseMaterialParams = {

						uniforms: uniforms,
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader

					};
					var baseMaterial = new THREE.MeshShaderMaterial( baseMaterialParams );
					renderer.initMaterial( baseMaterial, scene.lights, scene.fog );


					// copy materials to all geo chunks and add AO-texture

					materials = [];

					for( var i = 0; i < geometry.materials.length; i++ ) {
						
						materials[ i ] = new THREE.MeshShaderMaterial( baseMaterialParams );
						
						materials[ i ].program = baseMaterial.program;
						materials[ i ].uniforms = Uniforms.clone( uniforms );
						
						materials[ i ].uniforms[ 'targetStart'  ].value   = targetStart.position;
						materials[ i ].uniforms[ 'targetEnd'    ].value   = targetEnd.position;
						materials[ i ].uniforms[ 'map'          ].texture = geometry.materials[ i ][ 0 ].map;  
						materials[ i ].uniforms[ 'grassImage'   ].texture = uniforms[ 'grassImage'   ].texture;
						materials[ i ].uniforms[ 'surfaceImage' ].texture = uniforms[ 'surfaceImage' ].texture;
						
						geometry.materials[ i ][ 0 ] = materials[ i ];
						
					}


					// add mesh

					var mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial());
					mesh.scale.x = mesh.scale.y = mesh.scale.z = 0.10;
					mesh.position.z = 1000;
					
					scene.addObject( mesh );

				};


				loader.load( { model: "obj/max/street.js", callback: callbackScene } );

			}

			function animate() {

				requestAnimationFrame( animate );


				render();
				stats.update();

			}

			function render() {

				var time = new Date().getTime();

				targetStart.position.x = Math.cos( time * 0.001 ) * 150;
				targetStart.position.y = 0;
				targetStart.position.z = Math.cos( time * 0.001 ) * 200 - 1000;

				targetEnd.position.x = Math.cos( time * 0.002 ) * 150;
				targetEnd.position.y = 0;
				targetEnd.position.z = Math.cos( time * 0.002 ) * 200;


				if( renderPost ) {
					
					renderer.render( scene, camera, renderTarget );
					renderer.render( sceneScreen, cameraOrtho );
					
				} else {
					
					renderer.render( scene, camera );
					
				}

			}

			function onKeyDown( event ) {
				
				if( event.keyCode == 80 ) {
		
					renderPost = !renderPost;
		
				}
				
			}
			
			function onMouseMove(event) {

				mouseX = ( event.clientX - SCREEN_WIDTH * 0.5 ) / SCREEN_HEIGHT;
				mouseY = ( event.clientY - SCREEN_HEIGHT * 0.5 ) / SCREEN_WIDTH;
			}




		</script>

	</body>
</html>
