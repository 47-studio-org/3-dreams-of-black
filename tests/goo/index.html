<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js webgl - city</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				color: #808080;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				display:none;
			}

			a { color:red }

			.bar { width:100%; position:absolute; z-index:200; display:none }

			#oldie { z-index:500!important; margin-top:15em!important }

		</style>
	</head>

	<body>
		<div id="info">
			<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> - OBJ converter example
		</div>

		<div id="hud">
		</div>

		<div class="bar" id="topbar1"></div>
		<div class="bar" id="topbar2"></div>
		<div class="bar" id="bottombar1"></div>
		<div class="bar" id="bottombar2"></div>

		<script type="text/javascript" src="js/Three.js"></script>

		<script type="text/javascript" src="js/Detector.js"></script>
		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="js/Stats.js"></script>

		<script type="text/javascript">

			var Shaders = {

				'soup' : {

					uniforms: {

						"noise_image": { type: "t", value: 0, texture: null },
						"grass_image": { type: "t", value: 1, texture: null },
						"surface_image": { type: "t", value: 2, texture: null },
						"map": { type: "t", value:3, texture:null },

						"time": { type: "v2", value: new THREE.Vector2() },
						"target": { type: "v3", value: new THREE.Vector3() }

					},

					attributes: {
						
						"randomA": { type: "v3", value: [] },
						"randomB": { type: "v3", value: [] },
						
					},

					vertexShader: [

						"uniform vec3 target;",
						"uniform vec2 time;",
						
						"attribute vec3 randomA;",
						"attribute vec3 randomB;",

						"varying vec3 vWorldPosition;",
						"varying vec3 vNormal;",
						"varying vec2 vUv;",

						"void main() {",

							"vNormal = normalize( normalMatrix * normal );",
							"vUv = uv;",

							"vWorldPosition = vec3( objectMatrix * vec4( position, 1.0 )).xyz;",
							"float distance = max( 0.0, 1.0 - length( vWorldPosition - target ) * 0.0075 );",
							
//							"vec3 modifiedPosition = position + randomA * ( distance * time.x ) + randomB * ( distance * time.y );",
							"vec3 modifiedPosition = position + normalize( vWorldPosition - target ) * distance * 100.0;",
							"gl_Position = projectionMatrix * modelViewMatrix * vec4( modifiedPosition, 1.0 );",

						"}"

					].join("\n"),

					fragmentShader: [

						"uniform sampler2D noise_image;",
						"uniform sampler2D grass_image;",
						"uniform sampler2D surface_image;",
						"uniform sampler2D map;",
						"uniform vec3 target;",

						"varying vec3 vWorldPosition;",
						"varying vec3 vNormal;",
						"varying vec2 vUv;",

						"void main() {",

							"float f;",
							"vec3 normal;",
							"vec4 surface;",
							"vec4 grass;",

							"normal = vNormal * vNormal;",
							"vec3 worldPosition = vWorldPosition * 0.005;",
							
							"f  = 1.0 - length( vWorldPosition - target ) * 0.0025;",
							"f += texture2D( noise_image, worldPosition.xz ).x - 0.5;",

							"surface = texture2D( surface_image, worldPosition.yz ) * normal.x + ",
							          "texture2D( surface_image, worldPosition.xz ) * normal.y + ",
							          "texture2D( surface_image, worldPosition.xy ) * normal.z;",

							"if( f >= 0.0 ) {",

								"grass = texture2D( grass_image, worldPosition.yz ) * normal.x + ",
								        "texture2D( grass_image, worldPosition.xz ) * normal.y + ",
								        "texture2D( grass_image, worldPosition.xy ) * normal.z;",
	
								"surface = mix( surface, grass, smoothstep( 0.0, 0.1, f ));",
	
							"}",
	
							"gl_FragColor = surface * texture2D( map, vUv );",
						"}"

					].join("\n")

				}

			};

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var height = window.innerHeight;

			var container,stats;

			var camera, target, scene, renderer;

			var mesh, zmesh, geometry, materials, timer = new THREE.Vector2();

			var mouseX = 0, mouseY = 0, r = 0;
			
			
			

			init();
			animate();


			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);
				document.addEventListener( 'mousemove', onMouseMove, false );

				scene = new THREE.Scene();
				camera = new THREE.Camera( 50, window.innerWidth / window.innerHeight, 1, 10000 );


				target = new THREE.Mesh( new Sphere( 5, 5, 5 ), new THREE.MeshBasicMaterial( { color: 0xff0000 } ) );
				scene.addChild( target );

	
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.addChild( light ); 


				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				container.appendChild( renderer.domElement );
				renderer.setClearColor( 0xffffff );


				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );


				var loader = new THREE.JSONLoader(), callbackScene = function( geometry ) {

					// setup base material
 
					var shader = Shaders[ 'soup' ];
					var uniforms = shader.uniforms;

					uniforms[ 'noise_image' ].texture = ImageUtils.loadTexture( 'opengl/Texture_BlackSoup.jpg' );
					uniforms[ 'noise_image' ].texture.wrapS = THREE.RepeatWrapping;
					uniforms[ 'noise_image' ].texture.wrapT = THREE.RepeatWrapping;

					uniforms[ 'grass_image' ].texture = ImageUtils.loadTexture( 'opengl/Texture_Grass.jpg' );
					uniforms[ 'grass_image' ].texture.wrapS = THREE.RepeatWrapping;
					uniforms[ 'grass_image' ].texture.wrapT = THREE.RepeatWrapping;

					uniforms[ 'surface_image' ].texture = ImageUtils.loadTexture( 'opengl/Texture_Pavement.jpg' );
					uniforms[ 'surface_image' ].texture.wrapS = THREE.RepeatWrapping;
					uniforms[ 'surface_image' ].texture.wrapT = THREE.RepeatWrapping;

					
					var attributes = shader.attributes;
					
					for( var i = 0; i < geometry.vertices.length; i++ ) {
						
						var pos = geometry.vertices[ i ].position;
						
						attributes.randomA.value.push( new THREE.Vector3( 100,100,100 ));
						attributes.randomB.value.push( new THREE.Vector3( -100,-100,-100 ));
					}


					var baseMaterialParams = {

						attributes: attributes,
						uniforms: uniforms,
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader

					};
					var baseMaterial = new THREE.MeshShaderMaterial( baseMaterialParams );
					renderer.initMaterial( baseMaterial, scene.lights, scene.fog );


					// copy materials to all geo chunks and add AO-texture

					materials = [];

					for( var i = 0; i < geometry.materials.length; i++ ) {
						
						materials[ i ] = new THREE.MeshShaderMaterial( baseMaterialParams );
						
						materials[ i ].program = baseMaterial.program;
						materials[ i ].uniforms = Uniforms.clone( uniforms );
						
						materials[ i ].uniforms[ 'target'        ].value   = target.position;
						materials[ i ].uniforms[ 'time'          ].value   = timer;
						materials[ i ].uniforms[ 'map'           ].texture = geometry.materials[ i ][ 0 ].map;  
						materials[ i ].uniforms[ 'noise_image'   ].texture = uniforms[ 'noise_image' ].texture;
						materials[ i ].uniforms[ 'grass_image'   ].texture = uniforms[ 'grass_image' ].texture;
						materials[ i ].uniforms[ 'surface_image' ].texture = uniforms[ 'surface_image' ].texture;
						
						materials[ i ].attributes = {
							
							"randomA": { type: "v3", value: attributes.randomA.value, dirty: true },
							"randomB": { type: "v3", value: attributes.randomB.value, dirty: true },
							
						};
						
						geometry.materials[ i ][ 0 ] = materials[ i ];
						
					}


					// add mesh

					var mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial());
					mesh.scale.x = mesh.scale.y = mesh.scale.z = 0.10;
					mesh.position.z = 1000;
					
					scene.addObject( mesh );

				};


				loader.load( { model: "obj/max/street.js", callback: callbackScene } );

			}

			function animate() {

				requestAnimationFrame( animate );


				render();
				stats.update();

			}

			function render() {

				var time = new Date().getTime();

				target.position.x = Math.cos( time * 0.0011  ) * 100 - 50;
				target.position.y = Math.sin( time * 0.001   ) * 50;
				target.position.z = Math.cos( time * 0.00121 ) * 200 - 300;

				timer.x = Math.cos( time * 0.001 );
				timer.y = Math.sin( time * 0.001 );


				r -= mouseX * 2 * Math.PI / 180;

				camera.position.x = 300*Math.sin(r);
				camera.position.z = 300*Math.cos(r);
				camera.position.y = 200 * mouseY + 100;

		//		camera.target.position.set( target.position.x, target.position.y, target.position.z );


				renderer.render( scene, camera );

			}
			
			function onMouseMove(event) {

				mouseX = ( event.clientX - SCREEN_WIDTH * 0.5 ) / SCREEN_HEIGHT;
				mouseY = ( event.clientY - SCREEN_HEIGHT * 0.5 ) / SCREEN_WIDTH;
			}


		</script>

	</body>
</html>
