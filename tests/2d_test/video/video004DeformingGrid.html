<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>video test</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				background:#000000;
				color:#000;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:sans-serif;
				text-align:center;
			}
			canvas { pointer-events:none; z-index:10; }
		</style>
	</head>
	
	<body>

		<script type="text/javascript" src="build_r36/Three.js"></script>
		<script type="text/javascript" src="src/SpriteSheetShaderDeforming.js"></script>

		<video id="video" autoplay loop style="display:none">
			<source src="s02-1.webm" type='video/webm;'>
			<source src="s02-1.m4v" type='video/mp4;'>
			<source src="s02-1.ogv" type='video/ogg;'>
		</video>

		<script type="text/javascript">			
			var aspect = window.innerWidth / window.innerHeight;
			var fov = 45;
			var adj;

			var container, camera, scene, webglRenderer;			
			var video, texture, vplane;
			
			var xof = 0;
			
			var mouseX = 0;
			var mouseY = 0;

			var followX = 0;
			var followY = 0;

			var windowHalfX = window.innerWidth >> 1;
			var windowHalfY = window.innerHeight >> 1;
			
			var targetPos = new THREE.Vector4();

			init();	
			setTimeout( sequence, 1000/24 );		
			loop();
				
			setInterval(loop, 1000/24);
			
			document.addEventListener('mousemove', mouseMove, false);

			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);
				
				camera = new THREE.Camera( fov, aspect, 0.1, 10000 );
				
				camera.updateMatrix();

				scene = new THREE.Scene();
				scene.addLight( new THREE.AmbientLight( 0x000000 ) );

				video = document.getElementById( 'video' );
				video.addEventListener('ended', onVideoEnd, false);

				texture = new THREE.Texture( video );
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;

				var vidAspect = 544/960;
				
				vplane = new THREE.Mesh( new Plane(1.2, 1.2, 100, 50), new THREE.MeshBasicMaterial (
					{ map: texture } 
				));
				
				vplane.position.z = -1000;
			
				adj = Math.tan( fov * Math.PI / 360 ) * 2 * aspect;
				
				vplane.scale.x = Math.abs(vplane.position.z) * adj;
				vplane.scale.y = Math.abs(vplane.position.z) * adj * vidAspect;
							
				vplane.overdraw = true;
				vplane.doubleSided = false;
				vplane.updateMatrix();
				scene.addObject(vplane);
				
				camera.target.position = vplane.position;
				
				var shader = SpriteSheetShaderSource[ 'spriteSheet' ];
				var uniforms = Uniforms.clone( shader.uniforms );

				uniforms[ 'sheet' ].texture = ImageUtils.loadTexture( "textures/buffalo/sbufseq.png" );
				uniforms[ 'tileOffsetX' ].value = new THREE.Vector2(0.1, xof);
                uniforms[ 'mouseXY' ].value = new THREE.Vector2(mouseX, mouseY);
				
				buffaloMat = new THREE.MeshShaderMaterial( {
					uniforms: uniforms,
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader,
					blending: THREE.BillboardBlending,
                    wireframe: false
				} );


				var bufAspect = 129/230;
			
				//addBuffalo(.5, -750, bufAspect, -.5);
				addBuffalo(0.9, -125, bufAspect, .24);
				
				addBuffalo(.5, -700, bufAspect, -.25);
				//addBuffalo(.7, -75, bufAspect, -.5);
				
				
				
				var trainFrame = new THREE.Mesh( new Plane(1.2, 1.2, 100, 50), new THREE.MeshBasicMaterial ( 
					{ map: ImageUtils.loadTexture( "textures/buffalo/window.png" ), blending: THREE.BillboardBlending } 
				)); 	
						
				trainFrame.position.z = -100;
				trainFrame.scale.x = Math.abs(trainFrame.position.z) * adj;
				trainFrame.scale.y = Math.abs(trainFrame.position.z) * adj * 1/aspect;
				scene.addObject(trainFrame);
				
				try {
					webglRenderer = new THREE.WebGLRenderer( scene );
					webglRenderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( webglRenderer.domElement );
				} catch (e) {
				}
			}
			
			function addBuffalo(relativeSize, zpos, asp, xp){
				var buffalo = new THREE.Mesh( new Plane(relativeSize, relativeSize, 50, 50), buffaloMat );
				buffalo.position.z = zpos;
				
				buffalo.scale.x = adj * Math.abs(zpos);
				buffalo.scale.y = adj * asp * Math.abs(zpos);
				
				buffalo.position.y = adj * Math.abs(zpos) * -0.38 * asp;
				buffalo.position.x = adj * Math.abs(zpos) * xp;
				
				scene.addObject(buffalo);
			}

			function sequence() {		
				xof += 0.1;	
				if(xof > 0.9) xof = 0;
				buffaloMat.uniforms[ 'tileOffsetX' ].value.y = xof;
				setTimeout( sequence, 1000/24 );
			}

			function onVideoEnd() {
				video.play();
			}
			
			function mouseMove(e){
				mouseX = (event.clientX - windowHalfX) / -windowHalfX;
				mouseY = (event.clientY - windowHalfY) / windowHalfY;
                buffaloMat.uniforms[ 'mouseXY' ].value.x = -mouseX;
                buffaloMat.uniforms[ 'mouseXY' ].value.y = -mouseY;
			}

			function loop() {				
				var vt = vplane.geometry.vertices.length;

				if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
					if (texture) texture.needsUpdate = true;
				}
				
				targetPos.x = mouseX * 10;
				targetPos.y = mouseY * 5;
				
				targetPos.z = mouseX * -60;
				targetPos.w = mouseY * -30;
				
				camera.position.x += (targetPos.x - camera.position.x) / 10;
				camera.position.y += (targetPos.y - camera.position.y) / 10;
				
				camera.target.position.x += (targetPos.z - camera.target.position.x) / 10;
				camera.target.position.y += (targetPos.w - camera.target.position.y) / 10;

				webglRenderer.render( scene, camera );
			}


		</script>

	</body>
</html>