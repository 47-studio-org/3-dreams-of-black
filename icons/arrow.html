<!DOCTYPE html>
  <head>
    <style>
      * {
        margin:  0;
        padding: 0;
      }
    </style>
    <script type = "text/javascript" src = "http://georgealways.github.com/gee/build/gee.min.js"></script>
    <script type = "text/javascript" src = "https://github.com/dataarts/dat.gui/raw/build/DAT.GUI.min.js"></script>
    <script type = "text/javascript">

      window.onload = function() {

        var gee = new GEE({ fullscreen : true });
        var g = gee.ctx;

        var arrowHead = new ArrowHead(gee);
            arrowHead.stroke = false;

        var gui = new DAT.GUI();
            gui.add(arrowHead);

            // ro.me styles are default
            // for all classes.
            g.fillStyle = "#F15D22";

        gee.draw = function() {

          g.clearRect(0, 0, gee.width, gee.height);
          arrowHead.update().render();

        };

        function ArrowHead(gee, x, y, w, h) {

          var that = this;
          var g = gee.ctx;

          // Public variables ie. Target Variables
          this.x = x || (gee.width / 2.0);
          this.y = y || (gee.height / 2.0);

          this.angle = 0.0; // in radians please
          this.width = w || 54;
          this.height = h || 92;

          this.stroke = true;
          this.fill = true;

          // Internal vars ie. Actual Vars
          var angle = this.angle;

          this.update = function() {

            // ease to positions
            // figure out rotation
            angle = this.radians(this.angle);

            return this;  // Makes it chainable
          };
          
          this.render = function() {
            
            g.save();
            g.translate(this.x, this.y);
            g.rotate(angle);
            g.beginPath();
            g.moveTo(0, -(this.height / 2.0));                       // Zero Point (will help for the back)
            g.lineTo((this.width / 2.0), -(this.height / 2.0));      // First Point
            g.lineTo(0, (this.height / 2.0));                        // Second Point
            g.lineTo(-(this.width / 2.0), -(this.height / 2.0));     // Third Point
            g.closePath();
            if(this.stroke) g.stroke();
            if(this.fill) g.fill();
            g.restore();
            
            return this;  // Makes it chainable
          };
        }
        ArrowHead.prototype.ease = function(cur, tar, inc) {
          var dif = tar - cur;
          if(Math.abs(dif) <= inc) {
            cur = tar;
          } else {
            cur += dif * inc;
          }
          return cur;
        };
        ArrowHead.prototype.radians = function(n) {
          return (n / 360.0) * Math.PI * 2;
        };

        // TODO: Is made up of 3 ArrowHeads
        function ArrowTail(gee, x, y, w, h, l) {

          var that = this;
          var g = gee.ctx;

          // Public vars
          this.x = x || (gee.width / 2.0);
          this.y = y || (gee.height / 2.0);

          this.width = w || 53;
          this.height = h || 131;

          this.size = l || 3;
          this.spacing = 21;

          var arrowHeads = [];

          // Accumulate our tail
          for(var i = 0; i < this.size; i++) {
            var yOffset = i;
            arrowHeads.push(new ArrowHead(gee, this.x, this.y - (i * this.spacing)));
          }

        }

        // TODO: Contains 1 ArrowHead, 1 ArrowTail, + 1 body (a line segment)
        function Arrow() {
          
        }

      };

    </script>
  </head>
  <body>
  </body>
</html>